import { describe, it, expect } from 'vitest';
import {
  generateSecureToken,
  hashToken,
  isTokenExpired,
  getTokenExpirationTime,
} from './token-utils';

describe('Token Utilities', () => {
  describe('generateSecureToken', () => {
    it('should generate a 64-character hexadecimal string', () => {
      const token = generateSecureToken();
      expect(token).toMatch(/^[a-f0-9]{64}$/);
      expect(token).toHaveLength(64);
    });

    it('should generate unique tokens on each call', () => {
      const token1 = generateSecureToken();
      const token2 = generateSecureToken();
      expect(token1).not.toBe(token2);
    });
  });

  describe('hashToken', () => {
    it('should hash a token using SHA-256', () => {
      const token = 'test-token-value';
      const hash = hashToken(token);
      expect(hash).toMatch(/^[a-f0-9]{64}$/);
      expect(hash).toHaveLength(64);
    });

    it('should produce consistent hashes for the same input', () => {
      const token = 'test-token-value';
      const hash1 = hashToken(token);
      const hash2 = hashToken(token);
      expect(hash1).toBe(hash2);
    });

    it('should produce different hashes for different inputs', () => {
      const hash1 = hashToken('token1');
      const hash2 = hashToken('token2');
      expect(hash1).not.toBe(hash2);
    });

    it('should work with tokens generated by generateSecureToken', () => {
      const token = generateSecureToken();
      const hash = hashToken(token);
      expect(hash).toMatch(/^[a-f0-9]{64}$/);
    });
  });

  describe('isTokenExpired', () => {
    it('should return true if token is expired', () => {
      const pastDate = new Date(Date.now() - 1000); // 1 second ago
      expect(isTokenExpired(pastDate)).toBe(true);
    });

    it('should return false if token is not expired', () => {
      const futureDate = new Date(Date.now() + 1000); // 1 second from now
      expect(isTokenExpired(futureDate)).toBe(false);
    });

    it('should handle exact expiration time', () => {
      // Create a date slightly in the future to avoid race conditions
      const veryCloseToNow = new Date(Date.now() + 100);
      expect(isTokenExpired(veryCloseToNow)).toBe(false);
    });
  });

  describe('getTokenExpirationTime', () => {
    it('should return a date 1 hour from now by default', () => {
      const now = new Date();
      const expiresAt = getTokenExpirationTime();

      const diffMs = expiresAt.getTime() - now.getTime();
      const diffHours = diffMs / (1000 * 60 * 60);

      // Allow 5 seconds of drift due to test execution time
      expect(diffHours).toBeGreaterThan(0.99);
      expect(diffHours).toBeLessThan(1.01);
    });

    it('should return a date N hours from now when specified', () => {
      const now = new Date();
      const expiresAt = getTokenExpirationTime(2);

      const diffMs = expiresAt.getTime() - now.getTime();
      const diffHours = diffMs / (1000 * 60 * 60);

      // Allow 5 seconds of drift
      expect(diffHours).toBeGreaterThan(1.99);
      expect(diffHours).toBeLessThan(2.01);
    });

    it('should return a future date', () => {
      const expiresAt = getTokenExpirationTime();
      expect(isTokenExpired(expiresAt)).toBe(false);
    });
  });
});
